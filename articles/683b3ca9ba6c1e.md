---
title: "Rust における「変数」を本気で理解する"
emoji: "🦀"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["rust", "javascript", "variable"]
published: true
---

## はじめに

最近、業務とは別に Rust を触り始めました。
普段はフロントエンドエンジニアとして Vue / TypeScript
を中心に開発しており、状態管理やリアクティブなデータフロー、型による安全性にはある程度慣れた環境で仕事をしています。

そんな背景で Rust に触れてみると、最初につまずいたのが
**「変数」というあまりにも基本的な概念** でした。
`let` がデフォルトで再代入不可だったり、**再宣言（シャドーイング）**
という仕組みが普通に使われていたりと、JavaScript
では前提として意識していなかったルールが次々に出てきます。

ただ、この「変数まわりの違い」を丁寧に追っていくと、

* Rust がなぜ安全なのか
* なぜコンパイラがここまで厳しいのか

といった設計思想が、**変数という最小単位から一貫している**
ことが見えてきました。

この記事では、Rust を学び始めたフロントエンドエンジニアの視点から、

* Rust における
    * 再代入
    * 再宣言（シャドーイング）
    * const
* JavaScript（`let` / `const`）との違い

を、「変数」という初歩の初歩にフォーカスして整理していきます。

### 対象読者

:::message
本記事は、以下のような方を対象としています
:::

* Rust を学び始めた、もしくはこれから触ろうとしている人
* JavaScript / TypeScript など、他言語の経験があり、Rust の書き方に違和感を覚えた人
* 再代入・再宣言（シャドーイング）・const の違いを一度きちんと整理したい人

### 本記事で言及しないこと

:::message
本記事では以下の内容については言及しません
:::

* 所有権・借用・ライフタイムの詳細な解説
* `static` や `lazy_static` などの定数関連の発展的な話題
* パフォーマンスチューニングや内部実装の深掘り

本記事では、あくまで 「変数の振る舞い」そのもの にフォーカスします。


## Rust の `let` は「再代入不可」がデフォルト

まず、Rust では変数は次のように宣言します。

```rust:Rust
let x = 10;
x = 20; // コンパイルエラー
```

これはエラーになります。

理由はシンプルで、**Rust の変数はデフォルトで immutable（不変）**
だからです。

再代入したい場合は、明示的に `mut` を付けます。

```rust:Rust
let mut x = 10;
x = 20; // OK
```

### JavaScript と比較すると

```js:JavaScript
let x = 10;
x = 20; // OK
```

JavaScript の `let` はデフォルトで再代入可能です。\
Rust はその逆で、

> 「再代入するなら、その意図を明示しなさい」

という設計になっています。


## Rust の「再宣言（シャドーイング）」とは？

Rust には **再宣言（シャドーイング / shadowing）**
という仕組みがあります。

```rust:Rust
let x = 10;
let x = x + 1;
let x = x * 2;

println!("{}", x); // 22
```

ここで行われているのは **再代入ではありません**。\
**同じ名前で新しい変数を宣言している** のがポイントです。

* 以前の `x` はスコープ内で隠される（shadowed）
* 型が変わっても問題ない
* `mut` は不要

### 型が変わる例

```rust:Rust
let x = "123";
let x = x.len();

println!("{}", x); // 3
```

これは Rust 的にはとても自然な書き方です。


## JavaScript の再宣言との違い

JavaScript では、同一スコープでの再宣言はエラーになります。

```js:JavaScript
let x = 10;
let x = 20; // SyntaxError
```

一方 Rust では OK。

```rust:Rust
let x = 10;
let x = 20; // OK
```

JavaScript で近い挙動をするとしたら、

```js:JavaScript
let x = 10;
x = x + 1;
```

になりますが、これは **同じ変数の再代入** です。

Rust の再宣言は、

* 新しい変数
* 新しい型
* 新しい所有権

を持つ、まったく別物です。


## 再代入と再宣言の違い（整理）

| 観点 | 再代入 |  再宣言（シャドーイング） |
| ---- | ---- | ---- |
| キーワード | `let mut` | `let` |
| 変数の実体 | 同じ | 新しい |
| 型変更 | 不可 | 可能 |
| 所有権 | 継続 | 新規 |
| 意図 | 状態を変える | 値を変換する |


Rust では、

* **状態が変わるもの → `mut`**
* **値の変換 → 再宣言**

という使い分けが推奨されることが多いようです。


## `const` はどう違う？

Rust の `const` は、JavaScript の `const` とはかなり性格が違うように感じました。

```rust:Rust
const MAX_COUNT: i32 = 100;
```

### Rust の `const` の特徴

* 必ず **コンパイル時定数**
* 型指定が必須
* 再代入・再宣言ともに不可
* 実体はインライン展開される

```rust:Rust
const X: i32 = 10;
const X: i32 = 20; // エラー
```

### JavaScript の `const`

```js:JavaScript
const x = 10;
x = 20; // エラー

const obj = { a : 0 };
obj.a = 1; // OK
```

JavaScript の `const` は、

* **再代入不可**
* **中身の変更は可能**

というルールです。

Rust の `const` はもっと厳密で、

> 「完全に不変な定数」

です。



## Rust / JavaScript 比較まとめ

| 概念 | Rust | JavaScript |
| ---- | ---- | ---- |
| 再代入 | `let mut` |  `let` |
| 再宣言 | `let` で可能  | `let` では不可 |
| 型変更 | 再宣言で可能  | 動的 |
| const | 完全不変・コンパイル時  | 再代入不可 |


## なぜ Rust はこうなっているのか

Rust の変数設計は、

* 状態変化を最小限にする
* 値の変換を明示的にする
* コンパイラが安全性を保証しやすくする

という思想に基づいています。

「変数」という小さな単位でこれを徹底しているからこそ、

* 所有権
* 借用
* ライフタイム

といった他言語では見慣れない難しい概念も一貫して理解できるようになっている、と感じました。


## おわりに

Rust を学び始めて感じたのは、

> 「難しい」の正体は、知らないルールではなく
> **今まで意識してこなかった前提**

なのだということです。

変数という初歩の初歩を深掘りするだけでも、
Rust という言語の思想がかなり見えてきました。

これから Rust を触り始める初学者の方にとって、
この記事が「最初の引っかかり」をほどく助けになれば嬉しいです。
