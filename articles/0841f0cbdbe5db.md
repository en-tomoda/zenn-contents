---
title: "Rustにおける「所有権」を フロントエンドエンジニアが本気で理解する"
emoji: "🐥"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["rust", "javascript", "ownership"]
published: false
---

## はじめに

普段は Vue（Nuxt） を使って開発を行っているフロントエンドエンジニアです。  
エンジニアとしての技術的な幅を広げる目的で、低レイヤー言語である Rust の勉強を始めました。

Vue をメインに触っているということもあり、普段の開発では JavaScript / TypeScript を扱うことがほとんどです。  
そのため、メモリの確保や解放といった低レイヤーな話題を意識する機会はほとんどありませんでした。

学習にあたっては *[^1]The Rust Programming Language（The Book）* や  
オライリーの *[^2]プログラミング Rust* を読み進めながら、少しずつ理解を深めています。

その中でも、他の言語ではあまり意識することのなかった  
**「所有権（Ownership）」** という概念は、特に理解に手こずったポイントでした。

- 変数を代入しただけで使えなくなる  
- コンパイルエラーの理由が直感的に分からない  
- なぜそこまで厳密なルールが必要なのか腑に落ちない  

正直、触り始めた当初は  
「なぜこんな面倒な仕組みがあるんだろう」  
と感じていました。

ただ、所有権を **メモリ管理の視点から順を追って整理** して理解していくと、  
これは Rust が厳しいからではなく、  
**メモリ安全を実行時ではなくコンパイル時に保証するための設計**  
だということが見えてきました。

本記事は、Rust を学び始めた過程で理解した  
所有権の考え方を、備忘も兼ねてまとめたものです。 

本記事が Rust 初学者、特に JavaScript / TypeScript を主に触ってきた方の  
理解の一助になれば幸いです。

### 対象読者

:::message
本記事は、以下のような方を対象としています
:::

- Rust を学び始めた、もしくはこれから触ろうとしている人
- JS / TS などをメインに書いてきて、Rust の代入や変数の扱いに違和感を覚えた人
- 「なぜ代入しただけで使えなくなるのか」「なぜムーブが必要なのか」が腑に落ちていない人
- 所有権という概念を、まずは メモリ管理の視点から理解したい人

### 本記事で言及しないこと

:::message
本記事では以下の内容については言及しません
:::

- 借用（Borrowing）・参照（Reference）・ライフタイムの詳細なルール
- Rc / Arc / RefCell など、所有権を拡張するための発展的な仕組み
- unsafe や内部実装レベルでのメモリ管理の話
- パフォーマンスチューニングや最適化の話題

本記事では、あくまで

- 「Rust における所有権とは何か」
- 「なぜムーブという挙動が必要なのか」

を、JavaScript では意識せずに済んでいたメモリ管理 という観点から整理することにフォーカスします。


## なぜ JavaScript では困らなかったのか

普段 JavaScript / TypeScript を使って開発していると、  
メモリ管理について意識する場面はほとんどありません。

オブジェクトを生成しても、

```js
const user = { name: "moda" }
const anotherUser = user
```

のようなコードを書いたときに、

* このデータはどこに確保されているのか
* いつ解放されるのか

といったことを考える必要はありません。

これは JavaScript が ガベージコレクタ（GC） を備えており、
不要になったメモリをランタイムが自動的に回収してくれるからです。

その結果、開発者は

* メモリの所有者が誰か

* いつ解放すべきか

* 複数の参照が存在しても安全か

といった問題を、ほぼ意識せずにコードを書くことができます。

一方でこれは、
**「安全である理由が見えないまま使えてしまう」**
とも言えます。

JavaScript では、
メモリの寿命や所有者の概念はランタイムの内部に隠蔽されており、
開発者が直接向き合うことはありません。

Rust を触り始めて所有権に戸惑うのは、
これまで JavaScript が肩代わりしてくれていた
メモリ安全の責務が、開発者側に明示的に渡される
からだと感じました。

では、Rust がこの問題にどう向き合っているのか、
その中心となる概念である 所有権（Ownership） について整理していきます。

## 所有権とは

Rust の所有権は、
「メモリ上の値を誰が管理しているか」 を明確にするための仕組みです。

Rust の所有権ルールは、ひとまずこの3つだけ覚えればOKです。

1. **値には必ず所有者が1人だけいる**
2. **所有者は同時に複数存在できない**
3. **所有者がスコープを抜けると値は破棄される**

```rust
let s = String::from("hello");
```

例えば、このとき `"hello"` の所有者は `s` になります。


ここで一度、
普段私たちが使っている JavaScript では、この **「所有者」** という概念がどう扱われているか
を見てみます。

多くのフロントエンドエンジニアにとって、
JavaScript で変数を代入したときに
「誰がメモリを管理しているか」を意識することはほとんどないと思います。

しかし、この違いを理解すると、
なぜ Rust に所有権という仕組みが必要なのかが見えてきます。


JavaScript と Rust で 「代入が何を意味するか」 の違いを見てみます。

---

### JavaScript における代入

JavaScript では、オブジェクトを代入してもエラーにはなりません。

```js:JavaScript
const user = { name: "moda" }
const anotherUser = user

console.log(user.name)        // "moda"
console.log(anotherUser.name) // "moda"
```

このコードでは、

* `user` と `anotherUser` は 同じオブジェクトを参照 している

* 複数の変数が同じデータを持っていても問題にならない

という状態になっています。

このとき、

誰がこのオブジェクトを **「所有」** しているのか

いつ **メモリを解放すべき** なのか

といったことは、すべて JavaScript のランタイム（GC） が管理しています。

開発者は「参照が増えても安全である」ことを前提に、
何も意識せずコードを書くことができます。

---

### Rust における代入

一方、Rust で同じようなことをすると、挙動は大きく異なります。

```rust:Rust
let s1 = String::from("hello");
let s2 = s1;

println!("{}", s1); // コンパイルエラー
```

このコードでは、

String はヒープにデータを持つ型

`s1` が持っていた所有権が `s2` に 移動（ムーブ） される

という動きになります。

その結果、

`s2` が唯一の所有者になる

`s1` はもはや有効な値を持たない

ため、`s1` を使おうとするとコンパイルエラーになります。

Rust では
**「値には必ず1人の所有者しか存在できない」**
というルールがあるためです。


### コピーされる型もある

ちなみに、 Rust では、すべての代入がムーブになるわけではありません。

```rust:Rust
let x = 10;
let y = x;

println!("{}", x); // OK
```

`i32` のような

* サイズが固定

* スタック上に配置される

* 単純にコピーできる型

はコピー（Copy トレイト） されます。

※Copy トレイトが実装されている型は、代入時にムーブではなくコピーが行われます。


:::message
ここまでの整理

* JavaScript では代入＝参照の共有でも安全（GC が管理）
* Rust では代入＝所有権の移動（ムーブ）
* 所有権は「誰がメモリを管理するか」を明確にする仕組み
* ムーブは危険なメモリ操作を防ぐための設計
:::


ここまでで、Rust では代入時に所有権が移動（ムーブ）することを見てきました。

ただ、ここで一つ疑問が残ります。

```rust:Rust
let x = 10;
let y = x;

println!("{}", x); // OK
```

`i32`はOKな一方で、先ほどの `String` はムーブされてエラーになりました。

```rust:Rust
let s1 = String::from("hello");
let s2 = s1;

println!("{}", s1); // エラー
```


なぜ `i32` は問題なく使えて、
`String` だけがムーブされるのでしょうか？

この違いを理解するためには、
Rust がデータを **どこに、どのように配置しているか** を知る必要があります。

そこで次に、**スタックとヒープ** について整理していきます。


## スタックとヒープ

Rust の所有権を理解する上で欠かせないのが、  
**スタック（Stack）とヒープ（Heap）** という2つのメモリ領域です。

これは Rust 特有の概念ではなく、  
多くのプログラミング言語で共通するメモリの仕組みです。

ただし、JavaScript ではこの違いを  
開発者が意識する必要がほとんどありませんでした。

![スタックとヒープのイメージ画像](https://storage.googleapis.com/zenn-user-upload/d3d2bf3ea86c-20260103.jpg =700x)
*※ 本図は [The Rust Programming Language  （Steve Klabnik, Carol Nichols 著）](https://doc.rust-jp.rs/book-ja/ch04-01-what-is-ownership.html)より引用*


### スタック（Stack）

スタックは、以下のような特徴を持つメモリ領域です。

* サイズがコンパイル時に決まっている
* 高速にアクセスできる
* スコープを抜けると自動で解放される

```rust
let x = 10;
```

`i32` のような値はサイズが固定されているため、
スタック上にそのまま値が配置されます。

この場合、代入は単純に **値のコピー** になります。

```rust
let y = x;
```
スタック上の値はコピーしても安全なため、
Rust ではこのような型に Copy トレイトが実装されています。

---

### ヒープ（Heap）

一方、ヒープは次のような特徴を持ちます。

* サイズが実行時に決まる
* 柔軟だが管理が難しい
* 明示的な管理が必要になる

```rust
let s = String::from("hello");
```
`String` は文字数によってサイズが変わるため、
**実体データはヒープ上**に確保されます。

変数 `s` 自体は、

* ヒープ上のデータへのポインタ

* 長さ

* 容量

といった情報を **スタック上** に持っています。



## なぜヒープではムーブが必要なのか

もし `String` をコピーしてしまうと、

* 同じヒープ領域を指すポインタが複数存在する
* どちらがメモリを解放するのか分からなくなる

という問題が起きます。

これを許してしまうと、

* メモリの二重解放
* 解放済みメモリへのアクセス（ダングリングポインタ）

といった、非常に危険なバグにつながります。

Rust はこれらを防ぐために、

**ヒープデータを持つ型の代入では、所有権を移動（ムーブ）させる**

という設計を採用しています。

:::message
ここまでの整理

* スタック上の値はコピーしても安全
* ヒープ上の値は管理が難しい
* Rust は「誰が解放するか」を曖昧にしない
* その結果として所有権とムーブが必要になる
:::


## ムーブが起きると何が起こるか

前のスタックとヒープで、
**ヒープ上のデータを持つ型では 代入時にムーブが発生する** ことを見ました。

ここでは **「なぜムーブが必要か」** ではなく、
ムーブが起きた結果、変数がどういう状態になるのか を整理します。

### ムーブ後の変数の状態

```rust
let s1 = String::from("hello");
let s2 = s1;
```

このコードを境に、変数の状態は次のように変化します。


| 変数 | 状態 | 
| ---- | ---- |
| s2 | "hello" の唯一の所有者 |
| s1 | 無効な状態（使えない） |


重要なのは、`s1` が

null になるわけでも、空文字列になるわけでもなく

**そもそも使ってはいけない状態になる** という点です。

```rust
println!("{}", s1); // コンパイルエラー
```

Rust は、ムーブ後の変数に対するアクセスを
**コンパイル時に完全に禁止** します。

なぜ **「無効な変数」** を残すのか

ここで疑問に思うかもしれません。

なぜ `s1` を自動で消してくれないのか？

これは、Rust が

* 変数の存在
* 変数が有効かどうか

を **型システム** で管理している からです。

`let s2 = s1;` の時点で、

`s1` は **「所有権を持たない変数」**

という状態に遷移します。

その結果、
`String` を期待する場所で `s1` を使おうとすると
型チェックの段階で弾かれます。

### ムーブは「値の移動」ではない

ムーブという名前から、

メモリ上のデータが移動している

と感じるかもしれませんが、実際には違います。

ヒープ上の `"hello"` は同じ場所にある

移動しているのは **所有権** という概念

Rust では、

**「どの変数が、そのデータを管理する責任を持っているか」**

だけが切り替わります。

### ムーブはコードの意味を明確にする

ムーブによって、

* どの変数が有効か
* どの変数が責任を持つか

が、コード上で明示されます。

これはランタイムの挙動ではなく、
**ソースコードを読んだ時点で分かる** という点が重要です。

:::message
ここまでの整理
* JavaScript では、代入しても参照を共有するだけで安全  
  （ガベージコレクタがメモリ管理を肩代わりしてくれる）

* Rust では、ヒープ上のデータを持つ値を代入すると  
  **所有権が移動（ムーブ）** する
* 所有権とは  
  **「そのメモリを誰が管理・解放する責任を持つか」** を明確にする仕組み

* ムーブは不便にするための制約ではなく、  
  **二重解放や不正な参照といった危険なメモリ操作を防ぐための設計**
:::

## まとめ

本記事では、Rust の所有権について、
JavaScript では意識せずに済んでいた「メモリ管理」という視点から整理してきました。

JavaScript では、ガベージコレクタによって

* メモリの解放タイミング
* 所有者の管理
* 複数参照の安全性

といった問題をランタイムが肩代わりしてくれていました。

一方 Rust では、それらを コンパイル時に保証する ために、

* 値には必ず 1 人の所有者がいる
* ヒープ上のデータはムーブによって所有権を移動する
* 無効になった変数はコンパイル時に使用を禁止する

という、明確なルールが設けられています。

最初は

* なぜこんなに厳しいのか
* なぜ代入しただけで使えなくなるのか

と感じていた所有権ですが、
スタックとヒープ、メモリ管理の問題を順番に見ていくことで、

Rust が不便だからではなく、
**危険なことを事前にできなくしているだけ**

という設計思想が見えてきました。

所有権は、Rust の中核となる概念であると同時に、
その後に出てくる

* 借用（Borrowing）
* 参照（Reference）
* ライフタイム（Lifetime）

を理解するための土台でもあります。

本記事が、Rust を学び始めたばかりの方や、
JavaScript / TypeScript をメインに開発してきたフロントエンドエンジニアの方にとって、
自分と同じ疑問を整理するための一助 になれば嬉しいです。

[^1]: [The Rust Programming Language 日本語版](https://doc.rust-jp.rs/book-ja/ch04-01-what-is-ownership.html)
[^2]: [プログラミングRust 第2版](https://www.oreilly.co.jp/books/9784873119786/)